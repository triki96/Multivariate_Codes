/*****************************************************************************/
/********************************* MQ --> MLD ********************************/
/*****************************************************************************/

/********************************* Constants *********************************/

F := GF(2);

G_hat := Matrix(F, [[1, 0, 0, 1, 1, 0, 0, 1, 1, 1],
					[0, 1, 0, 0, 0, 1, 1, 1, 1, 1],
					[0, 0, 1, 1, 1, 1, 1, 1, 1, 1]]);

e_hat := Vector(F, [0, 0, 0, 0, 0, 0, 0, 1, 1, 1]);


/********************************** Utility **********************************/

/*
Applies the map tau: F^{10q} -> F^{3q} to a vector v_tilde = (v_1, ..., v_q).
The function constructs a vector by taking the first 3 entries of each
component v_i in v_tilde.
Input:
- v_tilde, vector of length 10q over F.
*/
function tau(v_tilde)
	
	v_out := [];						//Output list
	
	q := NumberOfColumns(v_tilde) / 10;
	v_seq := Eltseq(v_tilde);			//Sequence associated to v_tilde

	for i in [1..q] do
		index := (i - 1)*10 + 1;				//1, 11, ..., 10q-9

		v_out cat:= v_seq[index..index+2];
	end for;

	return Vector(F, v_out);
end function;

/*
function tau(v_tilde)
	
	q := NumberOfColumns(v_tilde) / 10;
	v_out := Vector(F, [0 : _ in [1..3*q]]);	//Output
	
	v_seq := Eltseq(v_tilde);			//Sequence associated to v_tilde

	for i in [1..q] do
		index := (i - 1)*10 + 1;					//1, 11, ..., 10q-9

		tmp := ColumnSubmatrix(v_tilde, index, 2);	//tmp = v~[index..index+2]

		v_out cat:= v_seq[index..index+2];
	end for;

	return Vector(F, v_out);
end function;
*/


/********************************* Reduction *********************************/

// Quadratic equations

/*
Returns the MLD instance (H^, s^, t^) associated to an MQ system in standard
form having only one quadratic equation "xy + z = 0".
*/
function quadrSing()

	// H^
	C_hat := LinearCode(G_hat);
	H_hat := ParityCheckMatrix(C_hat);
	
	// s^
	s_hat := e_hat * Transpose(H_hat);

	// t^
	t_hat := 3;

	return H_hat, s_hat, t_hat;
end function;

/*
Returns the MLD instance (H~, s~, t~) associated to an MQ system in standard
form having q quadratic equations of the form "x_i*y_i + z_i = 0".
Input:
- q, number of quadratic equations. 
*/
function quadrSyst(q)

	// Getting H^, s^ and t^ for a single quadratic equation
	H_hat, s_hat, t_hat := quadrSing();

	// H~
	D := [H_hat : _ in [1..q]];
	H_tilde := DiagonalJoin(D);

	// s~
	s_seq := &cat[Eltseq(s_hat) : _ in [1..q]];
	s_tilde := Vector(F, s_seq);				//Since H~ is block-diag and e~
												//is the concat of e^, s~ will
												//be the concat of s^

	// t~
	t_tilde := 3*q;

	return H_tilde, s_tilde, t_tilde;
end function;


// Linear equations

/*
Given a binary sequence a_f representing the coefficients of a linear
polynomial f in 3q variables, returns a vector of length 10q as follows:
	(v1, v2, v3, v4, v5, v6, ..) --> (v1, v2, v3, 0, .., 0, v4, v5, v6, 0, ..)
												 |--------|
												   7 zeros
Input:
- a_f, vector of length 3q over F;
- q, number of quadratic equations.
*/
function nu(a_f, q)
	
	nu_f := [];						//Output list

	a_seq := Eltseq(a_f);			//Sequence associated to a_f

	for i in [1..q] do
		index := (i - 1)*3 + 1;			//1, 4, ..., 3q-2

		nu_f cat:= a_seq[index..index+2];
		nu_f cat:= [F ! 0 : _ in [1..7]];
	end for;

	return Vector(F, nu_f);
end function;


// MQ --> MLD

/*
Returns the MLD instance (H, s, t) associated to an MQ system S in standard
form.
Input:
- S, sequence of polynomials over F forming a system in standard form.
*/
function reduction2MLD(S)
	
	// Creeating a sequence of linear polynomials in S
	LP := [];

	//..

	// H~, s~, t~
	q := #S - #LP;
	H_tilde, s_tilde, t_tilde := quadrSyst(q);

	// H
	H := H_tilde;

	// s
	s := s_tilde;

	// t
	t := t_tilde;

	return H, s, t;
end function;